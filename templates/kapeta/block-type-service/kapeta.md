#FILENAME:kapeta.md:write-always
# Kapeta Readme
This file contains some structural information about this service.

This file will be overwritten every time you change the service definition in Kapeta.

## Folder Structure
This service is structured as follows:

### Generated files
All files in the following folders are generated by Kapeta - and should not be edited manually.
* ```src/.generated/config```: Contains your configuration entities
* ```src/.generated/data```: Contains anything related to databases
* ```src/.generated/entities```: Contains the public entities used by the service.
{{#consumes 'kapeta/resource-type-rest-client'}}
* ```src/.generated/client```: Contains REST Clients.
{{/consumes}}
{{#provides 'kapeta/resource-type-rest-api'}}
* ```src/.generated/rest```: Contains REST API routes.
{{/provides}}

### Editable files
All other files are editable - and will not be overwritten by Kapeta unless explictly mentioned in the file.

* ```src/service```: Contains the service layer logic. This is where you should add your business logic

### Path alias for generated files

To import generated files you can use the following path alias:
```typescript
import { MyEntity } from 'generated:entities/MyEntity';
```

{{#provides 'kapeta/resource-type-rest-api'}}
## REST API 
To edit the REST API handlers edit the services found here:
{{#providers-of-type 'kapeta/resource-type-rest-api'}}
* [src/service/{{type metadata.name}}RouteService.tsx](src/service/{{type metadata.name}}RouteService.tsx)
{{/providers-of-type}}

These are generated as TSX files to make it simple to render emails using JSX syntax.

The service files will only be generated if they don't already exist - or if they have not
changed since the last time they were generated.

### Errors
To throw an error with a specific HTTP status code from a REST API handler - use the following code:
```ts
import { RESTError } from '@kapeta/sdk-rest-route';
throw new RESTError('User not found', 404);
```
or simply:
```ts
someHandler(req:Request, res:Response) {
    res.sendError('User not found', 404);
}
```

Any exceptions thrown that are not RESTError will be converted to a 500 error.

All errors will be formatted as JSON - with the following structure:
```json
{
    "error": "My error message"
}
```
{{/provides}}

{{#consumes 'kapeta/resource-type-rest-client'}}

## REST Clients
You'll find the REST clients in the following folder: ```src/.generated/client```

See below for details on how to use the REST clients.

{{#consumers-of-type 'kapeta/resource-type-rest-client'}}
### {{metadata.name}}
To use the "{{metadata.name}}" REST Client - simply add the following code to your service:

```typescript
import { {{type metadata.name}}Client } from 'generated:client/{{type metadata.name}}Client';


class MyService {
    private client: {{type metadata.name}}Client;
    
    constructor() {
        this.client = new {{type metadata.name}}Client();
    }
}
```
{{/consumers-of-type}}
{{/consumes}}
{{#consumers-of-type 'kapeta/resource-type-postgresql'}}
## Postgres: {{metadata.name}}
To use the "{{metadata.name}}" Postgres database - simply add the following code to your service:

```typescript
import { {{type metadata.name}}DB } from 'generated:data/{{type metadata.name}}DB';

class MyService {
    private db: {{type metadata.name}}DB;
    
    constructor() {
        /**
         * Note: The database is not ready initially. It will be loaded during startup.
         * It is guaranteed to be ready before the first request is handled.
         * This means that the this.db.client property will not be ready during startup.
         */
        this.db = new {{type metadata.name}}DB();
    }

    /**
     * The database client. 
     * A simple helper to make it a little shorter to access the database.
     */
    private get client() {
        return this.db.client;
    }

    /**
     * Example of how to use the database client.
     */
    async get{{type metadata.name}}() {
        return await this.client.{{metadata.name}}.findMany({});
    }
}
```
### Schema changes
This service uses Prisma to manage the database schema.

A prisma schema looks something like this: 
```prisma
model {{type metadata.name}} {
  id        String   @id @default(uuid())
  name      String?  @db.VarChar(255)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("{{metadata.name}}")
}
```

To edit the **{{metadata.name}}** database schema edit the Prisma schema files here:
- [db/{{metadata.name}}/schema.prisma](db/{{metadata.name}}/schema.prisma)

Read more about Prisma here:
https://pris.ly/d/prisma-schema

When you are done editing the schema, 
run the following command to generate a new database migration file:
```bash
npm run migrate:dev
```

Run the following command to apply the migration to your database:
```bash
npm run migrate
```
{{/consumers-of-type}}

{{#consumers-of-type 'kapeta/resource-type-mongodb'}}
## MongoDB: {{metadata.name}}
To use the "{{metadata.name}}" MongoDB database - simply add the following code to your service:

```typescript
import { {{type metadata.name}}DB } from 'generated:data/{{type metadata.name}}DB';

class MyService {
    private db: {{type metadata.name}}DB;
    
    constructor() {
        /**
         * Note: The database is not ready initially. It will be loaded during startup.
         * It is guaranteed to be ready before the first request is handled.
         * This means that the this.db.client property will not be ready during startup.
         */
        this.db = new {{type metadata.name}}DB();
    }

    /**
     * The database client. 
     * A simple helper to make it a little shorter to access the database.
     */
    private get client() {
        return this.db.client;
    }

    /**
     * Example of how to use the database client.
     */
    async get{{type metadata.name}}() {
        return await this.client.{{metadata.name}}.findMany({});
    }
}
```
### Schema changes
This service uses Prisma to manage the database schema.

A prisma schema looks something like this:
```prisma
model {{type metadata.name}} {
  id String @id @default(auto()) @map("_id") @db.ObjectId
  name      String?
  createdAt DateTime
  updatedAt DateTime

  @@map("{{metadata.name}}")
}
```

To edit the **{{metadata.name}}** database schema edit the Prisma schema files here:
- [db/{{metadata.name}}/schema.prisma](db/{{metadata.name}}/schema.prisma)

Read more about Prisma here:
https://pris.ly/d/prisma-schema

When you are done editing the schema,
run the following command to generate a new database migration file:
```bash
npm run migrate:dev
```

Run the following command to apply the migration to your database:
```bash
npm run migrate
```
{{/consumers-of-type}}

{{#consumes 'kapeta/resource-type-smtp-client'}}
## Emails

To send simple emails - use the following code:
```tsx
import { EmailClient } from '@kapeta/sdk-smtp-client';
const emailClient = new EmailClient();
await emailClient.send({
    from: 'support@kapeta.com',
    to: 'someone@somewhere.com',
    subject: 'Hi!',
    text: 'Hello World!',
    html: '<h1>Hello World!</h1>',
});
```
E-mails are send using nodemailer. Read more here:
https://nodemailer.com/about/

To send emails rendered using React - use the following code: 
```tsx
import { EmailClient } from '@kapeta/sdk-smtp-client';
const emailClient = new EmailClient();
await emailClient.sendReact({
    from: 'support@kapeta.com',
    to: 'someone@somewhere.com',
    subject: 'Hi!',
    body: <MyEmail />,
});
```
This uses react-email - read more here: https://react.email/

### Email templates
Email templates are simply React components which are rendered using [react-email](https://react.email/).

### Testing
When sending e-mails locally it will use gosmtpd - which doesn't actually send any e-mails. 
It has a web interface and API where you can see the e-mails that would have been sent.
Read more here:
https://gitlab.com/sorenmat/gosmtpd

{{/consumes}}
{{#consumes 'kapeta/resource-type-rabbitmq-subscriber'}}
## RabbitMQ Subscriber
To consume messages from a RabbitMQ queue a consumer is generated for you for each resource.

Use the constructor function to create a new consumer.

Below is an example of how to use the consumer to listen for messages on the queue:
```javascript
import { ConfigProvider, runApp } from '@kapeta/sdk-config';
import { createServer } from './src/server';
import { createRoutes } from 'generated:routes';
import { addEventsSubscriber } from 'generated:queues/events-subscriber';
import { TypedAsyncMessage } from '@kapeta/sdk-rabbitmq';
import { Event } from 'generated:entities/Logs';

// runApp is a helper function that will load the configuration from Kapeta and then run the provided function
runApp(async (configProvider: ConfigProvider) => {
    // Create the server - see src/server/server.ts for more information
    const server = createServer(configProvider);

    // Add a subscriber to the events queue
    await addEventsSubscriber(configProvider, (event:Event, msg:TypedAsyncMessage<Event>) => {
        console.log('Received events', events, msg);
    })

    // Includes the generated routes for your API resources
    server.use(await createRoutes(configProvider));

    server.start('rest');
}, __dirname);

```
{{/consumes}}
{{#provides 'kapeta/resource-type-rabbitmq-publisher'}}
## RabbitMQ Publisher
To publish messages to the RabbitMQ queue a publisher is generated for you for each resource.

Use the constructor function to create a new publisher.

Below is an example of how to use the publisher to publish a message to one or more exchanges:
```javascript
import { ConfigProvider } from '@kapeta/sdk-config';
import { createEventsPublisher } from 'generated:queues/events-publisher';

const configProvider = null; // Get this from somewhere

const eventsPublisher = await createEventsPublisher(configProvider);

await eventsPublisher.publish({
    data: { ... },
});
```
{{/provides}}

{{#consumes 'kapeta/resource-type-npm-registry'}}
## NPM Registries

{{#consumers-of-type 'kapeta/resource-type-npm-registry'}}
### {{metadata.name}}
To access the "{{metadata.name}}" NPM registry - the following will return the access details:

```typescript
import { runApp } from '@kapeta/sdk-config';
import { get{{type metadata.name}}Details } from 'generated:repository/{{snakeCase metadata.name}}-repository';

runApp(async (configProvider: ConfigProvider) => {
    const details = await get{{type metadata.name}}Details(configProvider);
    console.log(details);
}, __dirname);
```
{{/consumers-of-type}}
{{/consumes}}

{{#consumes 'kapeta/resource-type-docker-registry'}}
## Docker Registries

{{#consumers-of-type 'kapeta/resource-type-docker-registry'}}
### {{metadata.name}}
To access the "{{metadata.name}}" Docker registry - the following will return the access details:

```typescript
import { runApp } from '@kapeta/sdk-config';
import { get{{type metadata.name}}Details } from 'generated:repository/{{snakeCase metadata.name}}-repository';

runApp(async (configProvider: ConfigProvider) => {
    const details = await get{{type metadata.name}}Details(configProvider);
    console.log(details);
}, __dirname);
```
{{/consumers-of-type}}
{{/consumes}}

{{#consumes 'kapeta/resource-type-maven-registry'}}
## Maven Registries

{{#consumers-of-type 'kapeta/resource-type-maven-registry'}}
### {{metadata.name}}
To access the "{{metadata.name}}" Maven registry - the following will return the access details:

```typescript
import { runApp } from '@kapeta/sdk-config';
import { get{{type metadata.name}}Details } from 'generated:repository/{{snakeCase metadata.name}}-repository';

runApp(async (configProvider: ConfigProvider) => {
    const details = await get{{type metadata.name}}Details(configProvider);
    console.log(details);
}, __dirname);
```
{{/consumers-of-type}}
{{/consumes}}
